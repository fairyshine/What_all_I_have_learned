

# 思想

现在我们假设一个图有m个节点，n条边。首先，我们需要把m个节点看成m个独立的生成树，并且把n条边按照从小到大的数据进行排列。在n条边中，我们依次取出其中的每一条边，如果发现边的两个节点分别位于两棵树上，那么把两棵树合并成为一颗树；如果树的两个节点位于同一棵树上，那么忽略这条边，继续运行。等到所有的边都遍历结束之后，如果所有的生成树可以合并成一条生成树，那么它就是我们需要寻找的最小生成树，反之则没有最小生成树。

# 复杂度

| 平均时间复杂度 | O(\|E\|log⁡\|V\|) 或 O(\|E\|α(\|V\|)) |
| :------------- | ------------------------------------ |
| 空间复杂度     | O(\|E\|+\|V\|)                       |

# 伪代码

![Screenshot 2022-11-13 at 15.07.31](pic/Kruskal算法伪代码中文.png)

![Screenshot 2022-11-13 at 15.00.41](pic/Kruskal算法伪代码.png)